#!/usr/bin/env python3
import json
import struct
import sys
from base64 import b64encode
from websockets.sync.client import connect
from hashlib import sha256
from ecdsa import SECP112r1, SigningKey
from subprocess import run


MSGID_TEMP = 0x12
MSGID_ADD = 0x13
MSGID_START = 0x20
MSGID_RESET = 0x21


if __name__ == '__main__':
    HOST = sys.argv[1]
    TEAM_TOKEN = sys.argv[2]
    URL = f'{HOST}/{TEAM_TOKEN}/ws'
    with connect(URL) as ws:
        mask = (1<<64)-1
        counter = 0
        seed = 0

        # Figure out random state
        print('Finding seed...')
        ws.send(f'canframe:{MSGID_RESET}:')
        while counter < 5:
            msg = json.loads(ws.recv())
            if msg['msg'] != 'can' or msg['msgId'] != MSGID_TEMP:
                continue

            update = struct.unpack('<Q', bytes.fromhex(msg['data']))[0]
            seed = (seed + update) & mask
            counter += 1

        # Retrieve next nonce through calculation
        print(f'Seed: {seed}')
        randgen = run(
            './randgen/target/release/randgen',
            capture_output=True,
            input=struct.pack('<Q', seed)
        )
        k = int.from_bytes(randgen.stdout[:22], byteorder='big')
        k = k % SECP112r1.order
        print(f'nonce: {hex(k)}')

        # Trigger signatures to be sent out
        ws.send(f'sauce:Pepper Sauce')

        # Find the next signed message on the bus
        while True:
            msg = json.loads(ws.recv())
            if msg['msg'] != 'can' or msg['msgId'] == MSGID_START:
                continue

            data = bytes.fromhex(msg['data'])
            if len(data) <= 28:
                continue

            r = int.from_bytes(data[:14], byteorder='big')
            s = int.from_bytes(data[14:28], byteorder='big')
            h = int.from_bytes(sha256(data[28:]).digest()[:14], byteorder='big')
            r1 = pow(r,-1,SECP112r1.order)

            d = r1 * ((k * s) - h) % SECP112r1.order
            sk = SigningKey.from_secret_exponent(
                d,
                curve=SECP112r1,
                hashfunc=sha256
            )
            break

        with open('./privkey', 'wb') as f:
            f.write(sk.to_pem())

        payload = b'secret sauce'
        sig = sk.sign(payload)

        # Extract flag through secret recipe
        payload = b64encode(sig + payload)
        ws.send(f'canframe:{MSGID_START}:{payload.decode()}')
        flag = ''
        while True:
            msg = json.loads(ws.recv())
            if msg['msg'] != 'can' or msg['msgId'] != MSGID_ADD:
                continue
            data = bytes.fromhex(msg['data'])
            if data[28] != 0:
                continue

            flag += data[31:].decode().strip()
            if flag[-1] == '}':
                break

        print(f'flag1: {flag}')
